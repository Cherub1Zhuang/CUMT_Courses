# 资源

资源分为两类：可抢占资源和不可抢占资源。

**可抢占资源**：可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占资源。是不会产生死锁的。

**不可抢占资源**：是指在不引起相关的计算失败情况下，无法把它从占有它的进程处抢占过来。如果一个进程开始刻盘，突然蓝光光盘刻录机分配给另一个进程，那么将划坏蓝光光盘。在任何时刻蓝光光盘刻录机都是不可抢占的。是可以产生死锁的。

&nbsp;

&nbsp;

# 死锁简介

死锁的规范定义如下：

> 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁。

例如有两个进程C,D。有两个不可抢占资源U,T。同时C和D都需要U,T两个资源。然后C进程先占有资源U，D先占有资源T。这时C进程开始请求T资源。但是被D占有着T资源。D进程也开始请求U资源。但被C占有着U资源。这样就是一个典型的死锁状态。

&nbsp;

&nbsp;

## 死锁的四个必须条件

1. 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
2. 占有和等待条件。已经得到了某个资源的进程可以在请求新的资源。
3. 不可抢占条件。已经分配个一个进程的资源不能强制地被抢占，只能被占有它的进程显示的释放
4. 环路等待条件。死锁发生时，系统中一定有两个或者两个以上的进程组成一条环路，该环路的每个进程都在等待着下一个进程所占用的资源。

死锁发生时，以上四个条件一定时同时满足的。如果其中任何一个条件不成立，死锁就不会发生。

&nbsp;

## 死锁建模(图)

所谓的第四种环路的情况是什么呢？我们用圆环来表示进程。用方框来表示资源。用资源指向的箭头表示资源被某个进程占用。我们前面讲的死锁的状态就是这样形成一个环路:
 ![image-20201218144551836](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212620.png)



# 死锁检测和恢复

如今有四种处理死锁的策略：

1. 忽略该问题。也许如果你忽略它，他也会忽略你
2. 检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题
3. 仔细对资源进行分配，动态的避免死锁
4. 通过破坏引起死锁的四个必要条件之一，防止死锁的产生

## 1.鸵鸟算法

第一种是最简单的解决方法是鸵鸟算法：**把头埋到沙子里，假装根本没有问题发生。**如果死锁平均5年发生一次，而每个月系统都会因硬件故障，编译器错误或者操作系统故障而崩溃一次，那么大多数的工程师不会以性能损失为代价和可用性的代价去防止死锁。

&nbsp;

## 2.死锁的检测和死锁恢复

第二种技术就是死锁的检测和恢复。在使用这种技术时，系统并不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁后，采取措施进行恢复。

&nbsp;

### 每种类型一个资源的死锁检测

前面我们讲到过有个东西叫做资源进程图。让我们来看看这样一个图：
 ![image-20201218150336629](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212624.png)

很明显，D -> T -> E -> V -> G -> U -> D是环路，那就发生了死锁。那我们如何来解决呢？

很简单的一种思路就是检测一个图中是否有环路存在。想成这样就简单了。对每一个节点依次作为一棵树的根节点，然后进行深度优先搜索。如果碰到已经遇到过的节点，那么久找到一个环。如果回溯到所有的节点都没有发现环，那么这个久不存在环。

这里篇幅原因，又因为是深搜最基本的算法，故不做展示。

这种算法远不是最佳算法。但毫无疑问，该实例表明确实存在检测死锁的算法！

&nbsp;

### 每种类型多个资源的死锁检测

如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。有一种基于矩阵的算法来检测从P1 到 Pn这n个进程中的死锁。假设资源的类型数为m，E1代表资源类型1, Ei 代表资源Ei。E现有**资源向量**，代表每种已经存在的资源总数。

在任意时刻，某些资源已被分配所以不可用。假设**A是可用资源向量**，那么Ai表示当前可使用资源数。如果仅有的两台磁带机都分配出去了，那么Ai的值为0.

现在有两个数组：C代表当前分配矩阵，R代表请求矩阵。Cij代表进程i所持有的资源j的数量。同理，Rij代表Pi所需要的资源j的数量。最终的表示如图所示：
 ![image-20201218151357536](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212627.png)



那么死锁的检测算法如下：

1. 寻找一个没有标记的Pi，对于它而言R矩阵的第i行向量小于或等于A。
2. 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第一步。
3. 如果没有这样的进程，那么算法终止

算法结束时，所有没有标记过的进程(如果存在的话)都是死锁进程。

来看看实例：
 ![image-20201218152421881](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212630.png)

首先从P1开始到P3发现只有P3进程全部满足A中剩余的。所以将P3标记，然后A变成：A = (4, 2, 0, 0)。但是这样P1 和 P2都不能满足，所以现如死锁进程！

&nbsp;

### 从死锁中恢复

假设我们死锁检测算法已经成功地检测到死锁，那下一步该怎么办？当然需要一些方法使系统重新正常工作。让我们来看看有什么方法吧。

#### 1. 利用抢占恢复

这种方法可能需要进行人工干预。例如，要将激光打印机从它的持有进程那里拿走，管理员可以收集已打印好的文档并将堆积在一旁。然后，该进程被挂起。接着，打印机被分配给另一个进程。当那个进程结束后，堆在一旁的文档再被重新放回原处，原进程可重新继续工作。

再不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，**这种做法是否可行主要取决于该资源本身的特性。**则很大程度上取决于哪一个进程拥有比较容易回收的资源。

&nbsp;

#### 2. 利用回滚恢复

**对进程进行检查点检查,** 进程检查点检查就是将进程的状态写入一个文件以备以后重启。该检查点不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。为了使这一过程更有效，新的检查点不应覆盖原有的文件，而应写到新文件中。这样进程执行时，将会有一系列的检查点文件被累计起来。

一旦检测到死锁就恢复到最新的检测点状态。回滚到一些时间点，就可以让该进程获得一些其他资源。在检查点后所作的工作也会全部丢失。这样往往该进程会复位到一个更早的状态，那时他还没有取得所需资源，接着把这个资源分配个另一个死锁进程。**如果复位后的进程试图重新获得对该资源的控制，它就必须一直等到该资源可用为止。**



#### 3. 通过杀死进程恢复

删除环中的一个进程这样就可以开环。但是需要注意到删除那个进程，这很重要，如果删错了那就得不偿失。

&nbsp;

## * 3.死锁的避免

在大多数系统中，一次只请求一个资源。系统必须能够判断分配资源是否安全，并且只能在保证安全的条件下分配资源。问题是：是否存在一种算法总能够做出正确的选择从而避免死锁。答案使肯定的，但条件必须事先获得一些特定的信息。

### 安全状态和不安全状态

在任何时刻，当前状态包括E,A,C和R。如果没有死锁发生，并且即使所有进程突然请求对**资源的最大需求**，也任然存在某种调度次序能够使得每一个进程运行完毕，则称为该状态时安全的。

例如如下图就是安全的。从左到右，空闲数量始终能满足最大进程需求：
 ![image-20201218154356462](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212635.png)



最后这个就是不安全的，从左到右，由于中途在b -> c的过程中分配给A两个导致不能满足任何一个的最大需求：
 ![image-20201218154801347](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212637.png)



### * 单个资源的银行家算法

模型是一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度。算法要做的判断是对请求的满足时否会导致不安全状态。如果是，那就拒绝请求。如果满足请求后系统任然是安全的，就予以分配。

例如开始我们有10个空闲的资源。和贷款需要的最大需求。将客户比作进程，贷款单位比作资源，银行家比作操作系统。
 ![image-20201218161618599](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212640.png)

客户们各自做自己的生意，在某些时刻需要贷款(相当于在请求资源的那一刻)。在某一时刻如在第二个阶段里面是安全的，由于保留着2个单位，银行家就能拖延除了C意外的其他任何请求。因而可以让C先完成，然后释放C所占的4个单位资源。有了这4个单位资源，银行家就可以给D或B分配所需的贷款单位，以此类推。

银行家算法就是对每一个请求进程检测，检查如果这一请求是否会达到安全状态。若是，那么就满足该请求；否则，就推迟对这一请求的满足。为了检查状态是否安全，银行家需要考虑他是否有足够的资源满足一个客户。如果可以，那么这笔贷款是能够收回的，并且接着检查最接近最大限额的一个客户，一次类推。如果所有投资最终都能被收回，那么该状态就是安全的，最初的要求可以批准。

&nbsp;

### * 多个资源的银行家算法

多个资源的银行家算法也是同理。
 ![image-20201218162223167](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212643.png)

检查一个状态是否安全的算法如下：

1. 查找右边矩阵中是否有一行，其没有被满足的资源数均小于或等于A。如果不存在这样的行，那么系统将会死锁，因为任何进程都无法运行结束(假定进程会一直占有资源直到他们终止为止)。
2. 假若找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A上。
3. 重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；或者所有进程的资源需求都得不到满足，此时就是发生死锁。

&nbsp;

## 4.死锁预防

从前面的学习可以直到，死锁的避免从本质上是不可能的，因为它需要获知未来的请求，而这些请求时不可知的。所以让我们来看看实际时如何避免死锁的吧！

### 破坏互斥条件

先看第一个，如果资源不是被一个进程独占，那就不会发生死锁了。但是如果两个进程同时使用打字机的话，那就会造成混乱。所以限制还是对可抢占资源和不可抢占资源的限制。

不过，有一个小思路是经常可适用的。那就是，避免分配那些不是绝对必须的资源，**尽量做到尽可能少的进程可以真正请求资源。**

&nbsp;

### 破坏占有并等待条件

只要禁止已持有资源的进程再等待其他资源便可以消除死锁。一种实现方法是规定所有进程开始执行前请求所需资源。**如果所需的资源全部可用。那就分配给该进程，直到运行结束。如果一个或多个资源正在被使用，那么久不进行分配，进程等待**。 

但是这不能在开始就知道进程需要那些资源，要是开始就知道进程需要什么资源那就可以使用银行家算法。并且这样做的话效率不是很高，相当于一个资源只能在一个进程中执行。

### 破坏不可抢占条件

同样和第一个局限相同，类似打印机，要是能进行抢占那打印机就会乱成一团。

### 破坏环路等待条件

现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。

另一种方式是将所有的资源统一编号，如下图所示
 ![image-20201218212511501](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212647.png)

进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。
 ![image-20201218212549969](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201218212649.png)

尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。

