
# 内存分段

首先因为进程在内存中肯定是动态的，所以在寻址的时候比如 0x001寻到的地址不可能就是物理地址的0x001。所以我们在PCB(想成管理进程的表)中保留了基地址。然后进程换入换出的时候就通过加上PCB里面的基地址。

所以我们的程序时分段开始的，比如有数据段，代码段等等这些。然后一个进程里面有各种线程，那就可以通过进程里面的LDT表来实现`映射`。所以这就是基本的内存分区。

然后我们再在内存里面维护一个表，表中记录了内存的空闲内存。从某个基地址开始，长度偏移多少。这就涉及到不同的适配了。

* 首先适配(选取表中最开始的，这样时间最快)
* 最佳适配(选取一个分段中最适合即将要分配的内存)
* 最差适配(选取一个分段中最不适合即将要分配的内存)

但是这就免不了有很多碎片，因为你申请了在释放，肯定会有碎片。同时想想，要是我们将空闲分区合并。注意这时候在移动内存里面的东西，用户进程肯定会暂停，然后在算算如果1M/S那1G的紧缩时间为1000秒 ~ 17分钟，这是肯定不行的！！！

# 内存分页和分区

由此，根据前面的描述，我们可以通过使用分页来解决。我们将内存比作一个面包，将面包每个切成片，每个片只有4kb大小。这样就会很好，每个进程最多浪费4kb啊！

同时我们还要管理这些内存啊。有个东西就是`CR3`每个进程都有一个这个东西来记录相对应的页框号和页号相对应这样就能实现寻址了。

**为了提高内存的空间利用率，页应该小，但是页小了，页表就增加**，每个逻辑页号都有一个对应的页表，想一想，页表很大就造成了很大的压力。你看 4GB / 4KB = ? 要维护这么一个大表。一个进程是4MB的内存，要是系统中有10个进程，那就要40兆。

那我们就把32位的地址，有一些不用的去掉。这是一种尝试，这样确实可以减少内存的浪费，但是想一想，这样页号就不是均匀的了。

![image-20201216192828391](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194420.png)

那么这样的话我们怎么找到对应的地址呢？要是用顺序的话，那就没得谈时间不知道话多少，折半查找也是浪费时间的。

所以这个不可行！！

又来，我们可以将不用的页号标记有一个有效位，我们可以标记为0可以不用读取这个内存，这样寻址就是o(1)了，但是还是回到那个问题，表冗余的情况还是没有解决啊。

![image-20201216192941004](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194422.png)



那既要内存连续又要页表占用内存少怎么办呢？

这里我们就可以引入hash索引了。比如一本书肯定有章节，每个章节都有很多小结吧！那我们内存也可以啊。先找到章，然后再找到对应的页，这样就节省了空间！！！

![image-20201216193346373](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194425.png)



# 快表TLB

TLB是一组相连快速存储，是个寄存器。将最近使用的页号和对应的页框号对应起来。因为这个是物理硬件电路。可以只通过一次比对就能找到相应的内存。这样就不用查多级页表。

 ![image-20201216193509589](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194429.png)



# 实际的内存管理

实际的内存管理是段页结合的。用户希望内存的方式是以段来划分(这样对用户来说好区别)。而操作系统希望内存是通过页来划分(这样节省空间)。所以就有了我们的虚拟内存！！！！

用户直接操作的是虚拟内存，在虚拟内存中给用户代码分好段，然后将用户的段对应到实际物理内存中的时候用页的方式。

 ![image-20201216194112348](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194434.png)

同时这样也能防止进程操作到其他进程的地址。起到了保护的作用。然后虚拟内存中就存这每个段对真实的物理内存的映射。

![image-20201216194312121](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201216194436.png)

基本导学就到这。这是页面置换算法的基础。
