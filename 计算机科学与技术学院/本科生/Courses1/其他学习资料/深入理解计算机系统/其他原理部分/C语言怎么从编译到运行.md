# 计算机系统漫游

后面可能知识有点深，可酌情观看

[信息是位+上下文](#信息是位+上下文)

[C语言编译和运行过程](#C语言编译和运行过程)

[系统的硬件组成](#系统的硬件组成)

[从硬件角度看C语言的运行过程](#从硬件角度看C语言的运行过程)

[关于高速缓存](#关于高速缓存)



## 信息是位 + 上下文

我们的hello程序开始时从一个源文件hello.c开始的，这个源程序就是程序员通过编辑器创建并保存的**文本文件**，这个命名就是hello.c。里面就是我们刚学C语言必须要学的ASCII字符构成的。

比如我们这个程序

```c
#include <stdio.h>

int main() 
{
	printf("hello, world\n");
}
```

用ASCII码表示就是这样：

```asm
\u0023\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u0020\u003c\u0073\u0074\u0064\u0069\u006f\u002e\u0068\u003e\u000a\u000a\u0069\u006e\u0074\u0020\u006d\u0061\u0069\u006e\u0028\u0029\u0020\u000a\u007b\u000a\u0009\u0070\u0072\u0069\u006e\u0074\u0066\u0028\u0022\u0068\u0065\u006c\u006c\u006f\u002c\u0020\u0077\u006f\u0072\u006c\u0064\u005c\u006e\u0022\u0029\u003b\u000a\u007d
```

像hello.c这样只由ASCII字符构成的文件称为`文本文件`，所有其他文件则称为`二进制文件`。

所以。hello.c的表示方法说明了一个基本的思想：**系统中所有的信息--包括磁盘文件，存储器中的程序，存储器中存放的用户数据以及网络上传送的数据，都是由一串比特表示！！！**。区分不同数据对象的唯一方法时我们读到这些数据对象时的上下文。(比如在Java的class文件中，它前四个字节是魔数，这就是.class文件的上下文)。

在详细点解释就是：同样的字节序列在不同的地方表示的东西可能会不一样，有些可能表示一些整数，有的表示浮点，有的表示字符串，有的表示机械指令。这些的原理将在后面慢慢更新

>**旁注:C语言**
>
>​	C语言是贝尔实验室在1969年~1973年创建的。最经典的著作就是"K&R"中描述了ANSIC。
>
>* C与Unix操作系统关系密切。**C从开始就是作为一种用于Unix系统的程序语言开发出来的。(所以它就是个编写操作系统的语言，不是什么必须学的，对于学应用层面的也没那么重要！！！别被洗脑了！！！)**。Unix内核的大部分，以及所有它支持的工具和函数库都是用C语言编写的。因为Unix几乎全部是用C编写的，它就可以很方便地移植到新的机械上，这种特点为C和Unix赢来广泛支持
>* C语言小而简单。C语言的设计是由一个人而非一个协会掌握，所以简单明了。K&R这本书用例子和练习描述整个C语言和标准库，才261页？？？？？？？？？？？？？？？？？同时容易移植到不同计算机上
>* C是为实践目的设计的。**C是设计用来实现Unix操作系统的。**





## C语言编译和运行过程

### 编译过程

在Unix系统上，从源文件到目标文件转化是由`编译器驱动程序`完成的：

```shell
unix> gcc -o hello hello.c
```
每个实际的步骤是这样的,先例如我们的源文件这样的一个C语言,我们命名为`hello.c`：
```
#include <stdio.h>
int main(void) {
	printf ("Hello world\n");
	return 0;
}
```
这就算一个C语言文件了。然后分别执行下面几条指令就对应下面所说的不同阶段：
```
gcc -E hello.c -o hello.i # 将c文件通过预编译器编译成为.i文件。并存为hello.i
gcc -S hello.i -o hello.s # 同理 将.i文件通过编译转换为汇编文件。并存为hello.s
gcc -c hello.s -o hello.o # 统理 将.s汇编文件，通过汇编器编译为`可重定位目标程序`,并存为hello.o文件
gcc hello.o -o hello # 将.o文件转换为可执行文件。
./hello # 运行
```
最后的输出:
```
[root@localhost Cproject]# ./hello
Hello world
```

这里，gcc编译器驱动程序读取源程序文件hello.c,并把它翻译成一个可执行目标文件hello(windows是exe文件)。这个要四个过程完成，这四个过程分别是(`预处理器`, `编译器`, `汇编器`, `链接器`) 一起构成编译系统

![image-20201126211230580](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002133.png)

* 预处理阶段:  预处理器(cpp)根据以字符#开头的命令，修改原始C程序。比如hello.c中第一行的#include <stdio.h>指令告诉预处理器 **读取系统头文件stdio.h的内容，并把它直接插入到程序文本中去。结果得到另一个C程序**，通常以.i文件为扩展名
&nbsp; 

说简单点就是替换掉类似`#include <stdio.h>`的东西，然后删除你源程序的注释
&nbsp; 

源程序：![img](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205145901.png)
&nbsp; 

.i文件：![image-20201205144503044](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205144734.png)
由于GitHub图片总是出问题，前面的函数部分就不截图，总之就是含有extern的一个函数。但是并没有实现，然后等着链接阶段链接上来。


* 编译阶段: 将文本文件hello.i翻译成 **文本文件(还记得吗，全是用ASCII码表示的文件)** hello.s，它包含一个`汇编语言程序`。要解释汇编语言就是后话了。例如C编译器和Fortran编译器将hello.s产生的输出文件用的都是一样的汇编语言

&nbsp;

汇编阶段就是.i文件编程汇编文件:
 ![image-20201205145209270](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205145210.png)
注意源.i文件前面那一坨都被汇编用.开头的表示了，所以汇编这么简介。

&nbsp;

* 汇编阶段: 接下来，汇编器(as)将hello.s翻译成机械语言指令，把这些指令打包成为一种叫做`可重定位目标程序`的格式，并将结果保留在目标文件hello.o中。这时的hello.o文件是二进制文件。不能查看
* 链接阶段: 这里就是相当于符号替换(用Java来说就是解析阶段的把引用符号替换成直接符号)好 说人话== ，比如printf函数，实际上它是C库中的一个函数，每个C编译器都提供。printf函数存在于一个名为printf.o的单独编译的目标文件中，链接器就负责把这里的printf.o并入到hello文件中。生成一个可执行目标文件。


**emmm 在《计算机组成与设计》一书中第83页详细的讲了这个过程。大概有6页吧，太多就不赘述了**



> **旁注：了解编译系统如何工作的益处**
>
> * `优化程序性能` : 现代编译器已经很成熟了。但是为了写出高效的代码，我们就不得不了解编译器的内部工作。比如：一个switch语句是不是总比一系列的if-else语句高效地多？一个函数调用地代价有多大？while循环比do循环更有效吗？指针引用比数组索引更有效吗？相对于通过引用传递过来地参数求和，为什么用本地变量求和地循环，其运行就会快很多呢？为什么两个功能相近的循环运行时间会有很大差异？
> * `理解链接时出现的错误`: 比如，链接器报告说无法解析一个引用，这是什么意思？静态变量和全局变量区别是什么？静态库和动态库的区别是什么？为什么命令行上排列库的顺序是有影响的？最烦人的是，为什么有些连接错误直到运行时才出现？
> * `避免安全漏洞`: 这个关乎堆栈的管理，更是必须学的。



### 运行过程

此刻，我们的`hello.c`程序已经被编译系统转换成了可执行目标文件hello，并被保存在磁盘上。为了在Unix系统上运行该可执行文件，我们将它的文件名输入到称为`shell`的应用程序中：

```shell
unix> ./hello
hello, world
unix>
```

`shell`是一种命令行解释器，他输出一个提示符，等待你输入一个命令，然后执行这个命令(和Windows的cmd一样)。如果该命令的第一个单词不是内置的`shell`命令，那么`shell`就会假设这是一个可执行文件的名字，要**加载和执行**该文件。



下面部分可能需要一定计算机硬件知识。可选择性看一看。



## 系统的硬件组成

**总线：**

贯穿真个系统的是一组电子管道，叫做总线，携带的电子信息字节负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中的字节数是一个基本的系统参数，各个系统中也不尽相同。比如, Intel Pentium 系统的字长为4字节，而服务器类的系统，例如 Intel Itaniums和关断的Sun公司的SPARCS的字长为8字节。用于汽车和工业中的嵌入式控制器之类较小的系统的字长往往只有1或2字节。假定我们字长为4字节，并且假设总线一次只传一个字。



**I/O设备:**

I/O(输入/输出)设备是系统与外界的联系通道。比如：用户输入的键盘和鼠标，作为输出的显示器，和磁盘，还有音响。

每个I/O设备都是通过一个`控制器`和`适配器`与I/O总线连接起来的。**控制器和适配器之间的区别主要是组成方式**。控制器是I/O设备本身或是系统的主印制电路板上的芯片组，**而适配器则是一块插在主板插槽上的卡**。



**主存:**

主存是一个临时存储设备，在处理器执行过程中，他被用来保存数据。物理上就是由一组DRAM(动态随机存储器)芯片组成的。逻辑上来说，存储器是由一个线性的字节数组组成的，每个字节都有自己唯一的地址(数组索引)，这些地址从零开始。具体的东西后面再说



**处理器：**

中央处理器单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器(PC)的字长大小的存储设备(或寄存器)。在任何一个时间点上，**PC都指向主存中的某条机械语言指令**

从系统开始通电，直到系统断电，处理器一直在执行相同的任务：从程序计数器(PC)指向的存储器处读取指令，解释指令，执行指令。然后更新程序计数器指向下一条指令。

这样的操作在`主存`，`寄存器`文件和`算术逻辑单元`之间循环。寄存器文件是一个小的存储设备，由一些字长大小的寄存器组成，这些寄存器每个都有唯一的名字。ALU计算新的数据和地址值。



这就是计算机内部一个基本的构架：

![image-20201126220930967](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002136.png)





## 从硬件角度看C语言的运行过程

### 执行hello程序

首先，`shell`(前面说过的)程序执行命令，等待我们输入。当我们在键盘上输入字符串"./hello"后，shell程序就逐一读取字符到寄存器，再把它放到存储器中。![image-20201126223429565](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002138.png)

当我们敲击回车，`shell`就知道我们结束了命令的输入。然后`shell`执行一系列指令，将hello文件中的代码和数据从磁盘拷贝到主存，然后加载hello文件。数据最后会输出"hello, world\n"。

一旦hello目标文件中的代码和数据被加载到了存储器，处理器就开始执行hello程序**(这里是并发的执行，现在可能不知道但一定要记住，很重要)**的主程序中的机械语言指令。这些指令将"hello, world\n"串中的字节从存储器中拷贝到寄存器文件，再从寄存器中文件拷贝到显示器设备，最终显示再屏幕上。![image-20201126232439425](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002140.png)

![image-20201126232449502](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002142.png)





## 关于高速缓存

到这还没有把计算机硬件的全貌呈现给大家。不过到这就应该能明白C语言从编译到运行从硬件方面还有软件方面的一些常识了。但深入肯定这些不能满足，所以还是要考自己慢慢学，慢慢摸索吧。

现在把高速缓存聊一聊基本就是把计算机的整个核心聊完了，那开始吧==



通过上面的示例我们了解到，系统花费了大量时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是存放再磁盘上的。当程序加载，被拷贝到主存。当处理器运行，又从主存拷贝到处理器。从这个方向看，我们浪费了大量时间再指令的移动上面。

根据机械原理，较大的存储设备要比小的存储设备运行的要慢，而快速设备的造假要远高于低速同类设备。类似一个典型的寄存器文件只存储几百字节的信息，相反，主存可以存几百万字节。然而，处理器从寄存器文件中读数据比从主存中读数据要快100倍。随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。**加快处理器的运行速度比加快主存的处理速度要容易和便宜的多**

所以，就有了我们今天要聊的高速缓存。他们被用来作为暂时的集结区域，存放处理器再不久的将来可能会需要的信息。位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万的更大的L2高速缓存是通过一条特殊的总线连接到处理器的。进程访问L2的时间开销要比访问L1的时间开销大五倍，但着任然比访问主存的时间快5~10倍。![image-20201127000944514](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002146.png)





所以，综上我们就可以得到这个图：

![image-20201127001011850](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201127002147.png)



### 好了能看到这里的小伙伴相信对计算机很感兴趣。所以特此邀请维护我们的项目,里面有很多关于计算机原理的东西。一定能满足你的好奇心 [传送门](https://github.com/Alexiosvon/Hello_CUMTB)，如果觉得项目还行，就麻烦您点个star吧。维护不易
