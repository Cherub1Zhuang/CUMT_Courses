# HTTPS机制简述

[公开密钥加密](#公开密钥加密)

[RSA](#RSA)

[散列函数](#散列函数)

[数字签名](#数字签名)

[公钥认证](#公钥认证)

[使TCP连接安全：SSL](#使TCP连接安全：SSL)

## 公开密钥加密

首先我们先假想以下，互联网中两个人通信，Alice和Bob。Bob有两个密钥，一个是私钥一个是公钥，私钥是全世界只有自己能知道的，公钥是无论是谁都可以知道的。那么Alice要是想和Bob通信的话，就先用公钥加密一下报文，然后再发送给Bob，因为全世界只有Bob才知道私钥，所以Bob就可以收到Alice的信息了！

那问题来了，保证这个过程安全性的前提就是怎么保证这个加密/解密算法**不容易被第三方容易破解呢**？同时如何保证数据再传输的过程中不会被丢失呢？让我们后面来看吧！

## RSA

相信大家都对这个算法知道的或多或少。那就让我们来看看它的工作原理吧~

**首先要记住报文只不过是一种比特模式，并且所有比特模式能唯一地被一个整数表示。所以，当用RSA加密一个报文时，等价于加密该报文的这个唯一的整数。**

首先RSA有两个相互关联的部分：

* 公钥和私钥的选择
* 加密和解密算法

为了生成RSA的公钥和私钥，Bob执行如下步骤：

1. 选择两个大素数p和q。这个p和q选的越大越不容易被破解，但是相应的计算量也是逐渐增大的。RSA实验室推荐，公司使用时，p和q的乘积为1024比特的数量级。
2. 计算n = pq 和 z = (p - 1)(q - 1)
3. 选择小于n的一个数e，且使e和z没有公因数。这个e将会被用于加密
4. 求一个数d，使得e * d - 1可以被 z 整除。这个d将会被用于解密。 就是要让 ed mod z = 1。
5. Bob的公钥就是一对数 (n, e)，其私钥就是一对数(n, d)。

看看Alice执行加密过程，然后Bob执行解密过程吧：

* Alice假设要发送一个整数m的比特(m < n)为了进行编码，Alice执行指数运算 m^e^,然后计算m^e^被n的余数。就是 

c = m^e % n

* 为了对收到这个密文报文c解密，Bob计算

m = c^d % n

这个n和d就是bob的私钥。原理感兴趣的可以去看看《计算机网络自顶向下的方法》书中的第396页
![image](https://user-images.githubusercontent.com/57765968/111068666-b0f2d600-8504-11eb-93c9-5a6e63b0439d.png)


## 散列函数

那么过程之中的安全问题用公钥私钥加密机制能解决了。那如何保证传输程中的完整性呢？我们可以想到传两份报文，一个是正文，一个是经过散列的报文。如果Bob要想知道传输过程中是否被损坏就可以通过用散列函数对正文进行散列，然后和发过来的那个散列报文进行对比。如果对比成功那就算是过程中没有被损坏。反之则抛弃。

例如，原文是m那我们就发送 (m, H(m)),这就行了啊。

我们通常用的散列算法是MD5散列，有四大步骤

1. 填充 -- 先填1，然后填足够多的0，知道报文长度满足一定的条件
2. 添加 -- 再填充前添加一个用64比特表示的报文长度
3. 初始化累加器
4. 循环 -- 再最后的循环步骤中，对报文再16字块进行4轮处理

目前正在使用的第二个主要散列算法是安全散列算法 SHA-1。



## 报文鉴别码

我们现在再回到报文完整性的问题。既然我们理解了散列函数，就先来看一下将如何 执行报文完整性:

 1) Alice生成报文m并计算散列H(m)(例如使用SHA-1) 

 2)然后Alice将H(m)附加到报文m上，生成一个扩展报文(m, H(m)), 并将该 扩展报文发给Bob

 3) Bob接收到一个扩展报文(m, h)并计算H(m) 。如果H(m) = h, Bob得到结论：一切正常。 

这种方法存在明显缺陷。Trudy能够生成虚假报文m1，在其中声称她就是Alice,计算H(m1) 并发送给Bob (m1, H(m1))。 当Bob接收到该报文，一切将在步骤3中核对通过，并且Bob无法猜岀这种不轨的行为。 

为了执行报文完整性，除了使用密码散列函数外，Alice和Bob将需要共享秘密钥s。这个共享的秘密只不过是一个比特串，它被称为**鉴别密钥**。使用这个共享秘密，报文完整性能够执行如下：

1 ) Alice生成报文m,用s级联m以生成m+s,并计算散列H(m+s) (例如使用 SHA-1) 。 H(m + s)被称为报文鉴别码

2） 然后Alice将MAC附加到报文m上，生成扩展报文（m, H（m+s））,并将该扩展 报文发送给Bob。 

3） Bob接收到一个扩展报文（m，h）,由于知道s,计算出报文鉴别码H（m+s）。如 果H（m + s） = h,  Bob得到结论：一切正常。 
 ![image-20201211214623674](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211214625.png)

## 数字签名

那既然我们有了散列函数可以确保报文的完整性。但是，始终用散列函数发出去的消息还是明文啊。中途的`Trudy`要是截获报文，然后修改报文再本地进行散列还是没办法啊。所以我们就要讲讲数字签名了。

首先，对原文进行加密的代价是十分高昂的，如果我们先进行散列，然后对散列后的报文进行加密岂不美哉！

Bob让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数 字签名。明文形式的初始报文连同已经数字签名的报文摘要（从此以后可称为数字签名） 一道被发送给Alice。Alice先把发送方 的公钥应用于报文获得一个散列结果。然后她再把该散列函数应用于明文报文以得到第二 个散列结果。如果这两个散列匹配，则Alice可以确信报文的完整性及其发送方。

那对于`Bob`是这样的方式

 ![image-20201211205228489](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211205232.png)

对于`Alice`是这样的

 ![image-20201211205451187](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211205453.png)



## 公钥认证

数字签名的一个重要应用是**公钥认证**, 即证实一个公钥属于某个特定的实体。 我们回到问题，这确实可以保证报文在中途的安全性。但是好像不能准确的验证Bob真的是Bob，我们来看看这个图：

 ![image-20201211210018919](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211210021.png)

那这对于服务器的话，这个是很可怕的！那我们怎么验证呢？这就要有一个权威机构。让服务器厂商都去哪里注册，然后我们通过用其公钥解密验证报文，然后查看其中内容，确实如此这样才行！

所以就有了CA这个机构，让我们来看看CA这个机构到底干了什么事吧。

1. CA证实一个实体(一个人，一台路由器)的真实身份。

2. 一旦CA验证了某个实体的身份，这个CA会生成一个将其身份和实体的公钥绑定起来的证书。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息 (例如，一个人的名字或一个IP地址)。由CA对这个证书进行数字签名

    ![image-20201211210542462](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211210547.png)



## 使TCP连接安全：SSL



TCP的这种强化版本通常被称为安全套接字层

为了理解SSL的需求，我们浏览一下某典型的因特网商业的场景。Bob在Web上冲浪，到达了 Alice公司的站点，这个站点正在出售香水。Alice公司站点显示了一个表格, 假定Bob可以在该表格中输入香水的类型和所希望的数量、他的地址和他的支付卡号等信息。Bob输入这些信息，点击“提交”，就期待收到（通过普通邮政邮件）所购买的香水; 他也期待着在他的下一次支付卡报表中收到对所购物品的支付信息。所有这一切听起来不 错，但是如果不采取安全措施，Bob也许会有一些意外。 

* 如果没有使用机密性（加密），一个入侵者可能截取Bob的订单并得到他的支付卡 信息。这个入侵者则可以用Bob的费用来购买商品。 
* 如果没有使用完整性，入侵者可能修改Bob的订单，让他购买比希望瓶数多10倍 的香水。 
* 最后，如果没有使用服务器鉴别，这个显示Alice公司著名徽标的服务器实际上是 由Trudy维护的一个站点，Trudy正在假冒Alice公司。当Trudy收到Bob的订单 后，可能拿了 Boh的钱一走了之。或者Trudy可能充当一名身份窃贼，收集Bob 的名字、地址和信用卡号。 

SSL通过采用机密性、数据完整性、服务器鉴别和客户鉴别来强化TCP, 就可以解决 这些问题。 这也是我们在上文一直讨论的问题啊！！！

 ![image-20201211211558184](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211211600.png)

### 宏观描述

先描述一下其宏观过程，待会再补充细节我们把Bob想成客户端，Alice想成是服务端

1. **握手**

   在握手阶段，Bob需要：①与Alice创建一条TCP连接；②验证Alice是真实的Alice； ③发送给Alice 一个主密钥，Bob和Alice持用该主密钥生成SSL会话所需的所有对称密钥。注意到一旦创建了 TCP连接，Bob就向Alice发送一个 hello报文。Alice则用她的证书进行响应，证书中包含了她的公钥。 因为该证书已被某CA证实过，Bob明白无误地知道该公钥属于Alice然后，Bob产生一 个主密钥（MS）（该MS将仅用于这个SSL会话），用Alice的公钥加密该MS以生成加密 的主密钥（EMS）,并将该EMS发送给 Aliceo Alice用她的私钥解密该EMS从 而得到该MS。在这个阶段后，Bob和 Alice （而无别的人）均知道了用于这次 SSL会话的主密钥。 

2. **密钥导出**

   从原则上讲，MS此时已由Bob和Alice共享，它能够用作所有后继加密和数据完整性检查的对称会话密钥。然而，对于Alice和Bob每人而言，使用不同的密码密钥，并且对于加密和完整性检查也使用不同的密钥，通常认为更为安全。因此，Alice和Bob都使用MS 生成4个密钥:

   * E<sub>B</sub>  用于从Bob发送到Alice的数据的会话加密密钥
   * M<sub>B</sub>，用于从Bob发送到Alice的数据的会话MAC密钥 
   * E<sub>A</sub> ,用于从Alice发送到Bob的数据的会话加密密钥 
   * M<sub>A</sub>用于从Alice发送到Bob的数据的会话MAC密钥

   Alice和Bob每人都从MS生成4个密钥。 这能够通过直接将该MS分为4个密钥来实现。在密钥导岀阶段结束时, Alice和Bob都有了 4个密钥。其中的两个加密密钥将用于加密数据；两个MAC密钥将用 于验证数据的完整性。 有利这四个东西就可以进行通话了

 ![image-20201211213545304](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201211213548.png)

### 完整过程

1. **SSL握手**

   SSL并不强制Alice和Bob使用一种特定的对称密钥算法、一种特定的公钥算法或一 种特定的MAC。相反，SSL允许Alice和Bob在握手阶段在SSL会话开始时就密码算法取得一致。此外，在握手阶段，Alice和Bob彼此发送不重数，该数被用于会话密钥(E<sub>B</sub>, M<sub>B</sub>, E<sub>A</sub> 和 M<sub>A</sub>)的生成中。真正的SSL握手的步骤如下： 

   1）客户发送它支持的密码算法的列表，连同一个客户的不重数。

   2）从该列表中，服务器选择一种对称算法（例如AES）、一种公钥算法（例如具有 特定密钥长度的RSA）和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户。

   3）客户验证该证书，提取服务器的公钥，生成一个前主密钥(Pre-Master Secret, PMS), 用服务器的公钥加密该PMS, 并将加密的PMS发送给服务器。 

   4）使用相同的密钥导岀函数（就像SSL标准定义的那样），客户和服务器独立地从 PMS和不重数中计算出主密钥（Master Secret, MS）然后该MS被切片以生成两个密码和两个MAC密钥。此外，当选择的对称密码应用于CBC （例如3DES或AES）,则两个初始 化向量（Initialization Vector, IV）也从该MS获得，这两个IV分别用于该连接的两端。自 此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用MAC）。

   5）客户发送所有握手报文的一个MAC。

   6）服务器发送所有握手报文的一个MAC。 

2. **连接关闭**

   在某个时刻，Bob或者Alice将要终止SSL会话。一个方法是让Bob通过直接终止底层的TCP连接来结束该SSL会话，这就是说，通过让Bob向Alice发送一个TCP FIN报文段。但是这种幼稚设计为截断攻击创造了条件，Trudy再一次介入一 个进行中的SSL会话中，并用TCP FIN过早地结束了该会话。如果Trudy这样做的话, Alice将会认为她收到了 Bob的所有数据，而实际上她仅收到了其中的一部分。对这个问 题的解决方法是，在类型字段中指出该记录是否是用于终止该SSL会话的。（尽管SSL类型是以明文形式发送的，但在接收方使用了记录的MAC对它进行了鉴别。）通过包括这样 一个字段，如果Alice在收到一个关闭SSL记录之前突然收到了一个TCP FIN,她可能知道正在进行着某些耍花招的事情。 

完

&nbsp;
