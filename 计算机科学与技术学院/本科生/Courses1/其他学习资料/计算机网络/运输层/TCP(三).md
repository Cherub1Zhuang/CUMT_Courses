# 面向连接

[三次握手](#三次握手)

[四次挥手](#四次挥手)

# 三次握手

总所周知TCP要进行三次握手和四次挥手，那首先说说为什么要进行三次握手

首先，客户端和服务端通信要进行连接，“三次握手”的作用就是`双方都能明确自己和对方的收，发能力是正常的`

第一次握手：客户端发送网络包，服务端收到了。这样服务端就可以得出结论：客户端的发送能力，服务端的接受能力是正常的。

第二次握手： 服务端发包，客户端收到了。这样客户端可以得出结论：服务端的接收和发送能力，客户端的接受发送能力是正常的。

第三次握手： 客户端发包，服务端收到了。这样服务端能得出的结论：客户端的接收，发送能力，服务端的发送，接受能力都是正常的。



让我们来看看如何建立三次握手的吧：

* 第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部中的一个标志位 （即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客 户会随机地选择一个初始序号（client_isn）,**并将此编号放置于该起始的TCP SYN 报文段的序号字段中**。该报文段会被封装在一个IP数据报中，并发送给服务器。 
* 第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机, 服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，**该TCP报文段首部的确认号字段被置为client _ isn + 1**。最后，服务器选择自己的初始序号 （server_isn）,并将其放置到TCP报文段首部的序号字段中。该允许连接的报文段被称为SYNACK报文段（SYNACK segment）。 

* 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。**该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。** 

一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在 以后每一个报文段中，SYN比特都将被置为0。

&nbsp;

具体的连接情况如下：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201217212713.gif)

>  为什么TCP客户端最后还要发送一次确认呢？
>
> 主要防止已经失效的请求报文又传送到服务器，从而产生不必要的浪费
>
> 假设客户端发送一个请求连接，这个请求连接并没有丢失，但是因为链路拥堵的原因迟迟没有到服务器 。这时由于超时重传机制，客户端又发了一个请求连接包，但是可能这次的包发送很快就到达了服务器并且开始传送数据。但是这时客户端前面发的那个包又到达了服务器。这时由于两次握手不得不在给客户端进行连接，但是这确实是冗余并且没必要的



# 四次挥手

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

&nbsp;

&nbsp;

客户应用进程发出一个关闭连接命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。 这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1。服务器接收到该报文段后，就向发送 方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。 

具体可以看看此图：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201217213751.gif)



&nbsp;

> ### 为什么是三次握手，挥手确是四次
>
> 在握手时：服务器把收到消息的确认报文后把ACK和SYN放在一个报文里发送给客户端了
>
> &nbsp;
>
> 在挥手时：服务器收到对方的FIN报文时，收到建立连接请求的SYN报文后，把ACK和SYN报文分两次发送了。因为服务器收到客户端的FIN报文时，仅仅表示对方不再发送数据了，但是还能接受数据，而自己也未必全部数据都给了对方，所以服务器可以自己选择在发送报文给客户端还是直接断开连接。** 因此ACK和FIN会分两次发送，从而导致多了一次。
&nbsp;
&nbsp;


> ### 为什么客户端最后要等待2MSL？
>
> MSL(Maximum Segment Lifetime 最长报文段寿命), TCP允许不同的实现可以设置不同的MSL值。
>
> &nbsp;
>
> 一：**保证客户端发送的最后一个ACK报文能到达服务器**，因为这个报文可能会丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
>
> 二：如果客户端直接CLOSED，然后又再次向服务器发起一个新连接，谁也不能保证新发起的连接和刚关闭的连接的端口号是不同的，有可能新、老连接的端口号就是一样的。**假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。所以TCP连接还要在TIME_WAIT状态下等待2MSL，确保所有老连接的数据都在网络中消失！**
&nbsp;
&nbsp;


> ### 为什么时2MSL
>
> 首先，服务端在没有收到客户端的确认报文之前是不会释放给客户端分配的资源的。所以必须要保证能收到客户端的ACK报文服务端才释放资源
>
> 客户端并不知道服务端是否接到自己的ACK，客户端是这么想的：
>
> 1. 如果B没有收到自己的ACK，会超时重传FiN那么A再次接到重传的FIN，会再次发送ACK
> 2. 如果B收到自己的ACK，也不会再发任何消息包括ACK
>
> 无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：**去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这恰恰就是2MSL( Maximum Segment Life)。**
>
> 等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。同时也能保证网络中老的链接全部消失。
&nbsp;
&nbsp;


> ### 如果客户端出了故障怎么办
>
> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

