# 面向连接的TCP(二)

[可靠数据传输](#可靠数据传输)

[流量控制](#流量控制)

## 可靠数据传输

前面的文章说过，网络层(IP)服务是不可靠的。IP不保证可靠交付，不保证按序交付，也不保证数据的完整性。对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反）。

TCP在IP不可靠的尽力而为服务之上创建了一种**可靠数据传输服务**。假定发送的每一个报文段都与一个计时器相关联，这个概念上是最简单的。但是定时器的管理却要相当大的开销。**所以推荐的定时器管理过程仅使用一个重传定时器完成，**即使有多个已经发送但是未被确认的报文段。

我们先来讨论一下发送方高度简化的TCP:

我们看到在TCP发送方有3个与发送和重传有关的主要事件：从上层应用程序接收数据；定时器超时和收到ACK。

`一旦第一个主要事件发生`，TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。注意到每一个报文段都包含一个序号，这个序号就是该报文段第一个数据字节的字节流编号。还要注意到如果定时器还没有为某些其他报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。该定时器的过期间隔是TimeoutInterval他是EstimatedRTT和DevRTT计算得出的。

 ![image-20201212143052018](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212143055.png)

`第二个主要事件是超时`。TCP通过重传引起超时的报文段来响应超时事件。然后TCP 重启定时器。

`TCP发送方必须处理的第三个主要事件是`，到达一个来自接收方的确认报文段（ACK） （更确切地说，是一个包含了有效ACK字段值的报文段）。当该事件发生时，TCP将ACK的值y与它的变量`SendBase`进行比较。TCP状态变量`SendBase`是最早未被确认的字节的序号。 **因此SendBase - 1是指接收方已正确按序接收到的数据的最后一个字节的序号。**如前面指出的那样，TCP采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。**如果y > SendBase, 则该ACK是在确认一个或多个先前未被确认的报文段。因此发送方更新它的SendBase变量；如果当前有未被确认的报文段，TCP还要重新启动定时器。** 



### 一些有趣的情况

`第一种情况`：主机A向主机B发送一个报文段。假设该报文段的序号是92, 而且包含8字节数据。在发岀该报文段之后，主机A等待一个来自主机B的确认号为100的报文段。虽然A发出的报文段在主机B上被收到，但从主机B 发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早 已收到的数据。因此，主机B中的TCP将丢弃该重传的报文段中的这些字节。 

 ![image-20201212144531052](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151822.png)

`第二种情况`：主机A连续发回了两个报文段。第一个报文段序号是92包含8字节数据；第二个报文段序号是100,包含20字节数据。假设两个报文段都完好无损地到达主机B, 并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100, 第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。 
 ![image-20201212144751593](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151826.png)



`第三种情况`：假设主机A与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报文在网络丢失，但在超时事件发生之前主机A收到一个确认号为120的确认报文。主机A因而知道主机B已经收到了序号为119及之前的所有字节; 所以主机A不会重传这两个报文段中的任何一个。

 ![image-20201212144848195](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151829.png)





### 快速重传

超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时, 这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。冗余ACK就是再次确认某个报文段的ACK,而发送方先前已经收到对该报文段的确认。

因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK,它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到三个冗余的ACK报文，**那TCP就会执行快速重传**，快速重传就是不用等到超时的时候在传，而是立即就重传冗余的报文。伪代码如下：

 ![image-20201212145711076](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212145713.png)



## 流量控制

TCP为它的应用程序提供了`流量控制服务`以消除发送方使接收方缓存溢岀的可能性。流量控制因此是一个`速度匹配服务`，**即发送方的发送速率与接收方 应用程序的读取速率相匹配。**前面提到过，TCP发送方也可能因为IP网络的拥塞而被遏制；这种形式的发送方的控制被称为**拥塞控制**, 我们将在后面详细讨论。**即使流量控制和拥塞控制采取的动作非常相似但是它们显然是针对完全不同的原因而采取的措施。**

TCP通过让发送方和接收方各自维护一个称为`接收窗口`的变量来提供流量控制。接收窗口用于给发送方一个指示一一该接收方还有多少可用的缓存空间。我们在文件传输的情况下研究接收窗口。假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配了一个接收缓存，并用`RcvBuffer`来表示其大小。主机B上的应用进程不时地从该缓存中读取数据。我们定义以下变量:  

* LastByteRead: 主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。 
* LastByteRcvd: 从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个 字节的编号。

由于TCP不允许已分配的缓存溢出，下列必须成立：

 ![image-20201212151809385](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151839.png)

接收窗口用`rwnd`表示，根据缓存可用空间的数量来设置：

 ![image-20201212151801216](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151842.png)

所以这个`rwnd`是随着时间变化而变化的。

 ![image-20201212150638824](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151844.png)

开始时，主机B设定 rwnd = RcvBuffer。

&nbsp;

主机A轮流跟踪两个变量，`LastByteSent`和`LastByteAcked`, 这两个变量的意义很明显。 注意到这两个变量之间的差`LastByteSent - LastByteAcked`,就是主机A发送到连接中但未被确认的数据量。通过将未确认的数据量控制在值rwnd以内，就可以保证主机A不会使 主机B的接收缓存溢出。因此，主机A在该连接的整个生命周期须保证: 

 ![image-20201212151749669](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201212151849.png)

对于这个方案还存在一个小小的技术问题。假设主机B的接收缓存已经存满，使得rwnd = 0。在将rwnd = 0通告给主机A之后，还要假设主机B没有任何数据要发给主机A。此时，考虑会发生什么情况。因为主机B上的应用进程将缓存清空，TCP并不向主机A发送带有rwind新值的新报文段；事实上，TCP仅当在它有数据或有确认要发时才会发送报文段给主机A。这样，主机A不可能知道主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能再发送数据！为了解决这个问题，**TCP规范中要求：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的 rwnd 值。** 

