# 拥塞机制

分组重传作为网络拥塞的征兆来对待，但是却无法处理导致网络拥塞的原因，因为有太多的源想通过高的速率发送数据。为了处理网络拥塞的原因，需要一些机制以在面临网络拥塞时遏制发送方。

# 拥塞控制的原因

首先来想想为什么会有拥塞机制。假设路由器之间没有缓存限制，那么可以完全放开传送数据。更本不需要拥塞。但这在现实中肯定不是这样的。

每个路由器都有缓存的。假设缓存大小是R。输入的流量为R/S,输出只有R/(2 * S)。这输入路由器缓存肯定是顶不住的。有些数据肯定会丢失，但是如果用到了TCP的重传机制，那么就会无线发报文。一直发报文那毫无疑问，网络环境只会越来越差。所以就需要有用拥塞机制。

# 拥塞控制方法

这里指出实践中常用的两种主要拥塞控制方法，在最为宽泛的级别上，**我们可以根据网络层是否为运输层拥塞控制提供显示帮助，来区分拥塞控制方法。**

* **端到端拥塞控制**：在端到端控制方法中，**网络层没有为运输层提供拥塞控制显示支持**。即使网络中存在拥塞，端系统也必须通过对网络行为的观察来推断。TCP采用端到端方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失被认为是网络拥塞的一个迹象，TCP会相应地减少其窗口长度。
* **网络辅助的拥塞控制**：在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显示反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。



# TCP的拥塞控制

前面一节指出，TCP为全双工端到端系统，所以TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显示的网络拥塞反馈

TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。**如果一个TCP发送方感知从它到目的地之间的路径上没有拥塞，则TCP发送发增加其发送速率；如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率。**

**那问题来了：**

1. **一个TCP发送方如何限制它发送流量的速率呢？**
2. **一个TCP发送方如何感知它到目的地之间的路径上存在拥塞呢？**
3. **当发送方感知到 端到端的拥塞时，采用何种算法来改变其发送速率呢？**

## 1. 限制流量发送

现来分析一下TCP如何限制流量发送的。TCP连接的每一端都是由一个接受缓存，一个发送缓存和几个变量组成的。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口。拥塞窗口表示为cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。意思是发送方中未被确认的数据量不会超过cwnd与rwnd中的最小值，即：
$$
LastByteSent - LastByteAcked ≤ min (cwnd, rwnd )
$$


## 2. 发送方如何感知与目的路径出现拥塞

我们将一个TCP发送方的“==丢包事件==”定义为：**要么出现超时，要么收到来自接收方的3个冗余ACK。**当出现过度的拥塞时，在沿着这条路径的一台路由器缓存溢出，引起一个数据报被丢弃。丢弃的数据报接着会引起发送方的丢包事件，发送方就认为在发送方到接收方的路径上出现了拥塞的指示。



## * 3. 怎么改变发送速率

考虑了拥塞检测问题后，我们接下来考虑网络没有拥塞这种更为乐观的情况，即没有出现丢包事件的情况。在此情况下，在TCP的发送方将收到对于以前未确认报文段的确认。如果确认以高速率到达，**则该拥塞窗口将会更为迅速地增大。因为TCP使用确认来触发增大它的拥塞窗口长度**，TCP被说成是**==自计时==**的。

现在想想，如果发送方发送太快会造成拥塞网络。如果发送太慢会造成不能充分利用可用的带宽。所以TCP用一下原则来实现TCP发送速率控制。

* 一个丢失的报文段意为着拥塞，因此当丢失报文段时应当降低TCP发送方的速率
* 一个确认报文指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率
* 带宽探测：TCP调节其传输速率的策略是增加其速率以响应到达的ACK,除非岀现 丢包事件，此时才减小传输速率。因此，为探测拥塞开始出现的速率，TCP 发送方增加它的传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化。



# TCP控制算法

TCP控制发送速率主要有三个部分

1. 慢启动
2. 拥塞避免
3. 快速恢复

慢启动和拥塞避免时TCP的强制部分，两者差异在于对收到的ACK做出反应时增加cwnd长度的方式。慢启动比拥塞避免能更快地增加cwnd的长度。快速恢复时推荐部分，对TCP发送方并非是必须的。

## * 1. 慢启动

当一条TCP连接开始时，cwnd的值通常初始置为一个MSS的较小值，这就使得初始发送速率大约为MSS/RTT。由于对TCP发送方而言，可用带宽可能比MSS/ RTT大得多，TCP发送方希望迅速找到可用 带宽的数量。因此，**在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加1个MSS。**TCP向网络发送第一个报文段并等待一个确认。`当该确认到达时，TCP发送方就将拥塞窗口增加一个MSS`，**==这样下去在慢启动状态下就是以指数速率增长的==**。

但是如何结束这种指数增长呢？

* 第一种方式。如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程。他还将第二个状态变量的值ssthresh("慢启动阈值"的速记)设置为cwnd/2，即当检测到拥塞时将ssthresh置为拥塞窗口值得一半。

* 慢启动结束的第二种方式是直接与ssthresh的值相关联。因为当检测到拥塞时ssthresh设为cwnd的值的一班，当到达或超过ssthresh的值时，继续使cwnd翻番可能有些鲁莽。因此，当cwnd的值等于ssthresh时，结束慢启动并且TCP转移到拥塞避免模式。

* 最后一种就是当检测到3个冗余的ACK，这时TCP执行快速重传并进入快速恢复状态。
![image](https://user-images.githubusercontent.com/57765968/111062281-e8e92180-84e2-11eb-8365-2d5afad56e0d.png)

&nbsp;

## * 2. 拥塞避免

**一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不远**，因此，TCP无法每过一个RTT再将cwnd的值翻番，即用一种保险的方法，每个RTT只将cwnd的值增加一个MSS。每个RTT只将cwnd的值增加一个MSS。这能够以几种方式完成。一种通用的方法是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个 MSS字节。例如，如果MSS是1460字节并且cwnd是14 600字节，则在一 个RTT内发送10个报文段。每个到达ACK （假定每个报文段一个ACK）增加1/10MSS 的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一 个 MSS。 

但是何时应当结束拥塞避免的线性增长（每RTT 1MSS）呢？

* 当出现超时时：TCP的拥塞避免算法行为相同。与慢启动的情况一样，cwnd的值被设置为1个MSS。ssthresh的值被更新为cwnd值的一半。
* 当丢包事件发生时：TCP将cwnd的值减半（为使测量结果更好，计及已收到的3个冗余的 ACK要加上3个MSS）,并且当收到3个冗余的ACK,将ssthresh的值记录为cwnd的值的一半。接下来进入快速恢复状态。 

## * 3. 快速恢复

在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的 ACK, cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低 cwnd后进入拥塞避免状态。

超时事件：不管是发生超时指示的丢包事件，还是发生3个冗余ACK指示 的丢包事件，都无条件地将其拥塞窗口减至1个MSS,并进入慢启动阶段。cwnd的值被设置为1个 MSS,并且ssthresh的值设置为 cwnd值的一半。
