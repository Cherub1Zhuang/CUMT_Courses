# 数据库进阶

* [MySQL逻辑构架](#MySQL逻辑构架)
* [并发控制](#并发控制)
* [事务](#事务)
* [多版本并发控制](#多版本并发控制)
* [MySQL的存储引擎](#MySQL的存储引擎)

&nbsp;

## MySQL逻辑构架

如果能在头脑中构建一副MySQL各组件之间如何协同工作的构架图，就会有助于深入理解MySQL服务器。

![image-20201205163417460](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205163420.png)

最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等等。



第二层，大多数MySQL的核心服务功能都在这一层，包括**查询解析，分析，优化，缓存以及所有的内置函数(例如 ，日期，时间，数学和加密函数)**，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等



第三层，包含了存储引擎。负责MySQL中数据的存储和提取，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异。



### 连接管理与安全

**每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行**，该线程只能轮流在某个CPU核心或者CPU中运行。

当客户端连接到MySQL服务器时，服务器要对其进行认证。认证基于用户名，原始主机信息和密码。如果用了安全套接字(SSL),还可以使用X.509进行认证。连接成功，服务器就会继续验证这个连接的客户的权限(例如：是否可以执行select，updata)



### 优化与执行

MySQL会解析查询，并创建内部数据结构(解析树),然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。**用户可以通过特殊的关键字提示(hint)优化器**，影响它的决策。**也可以请求优化器解释(explain)优化过程的各个因素**。



**优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。**优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。如某些存储引擎的某种索引，可能对一些特定的查询有优化。



对于SELECT语句，解析查询之前，**服务器会先检查查询缓存**，如果能够在其中找到对应的查询，服务器就不必再执行查询解析，优化和执行的整个过程，而是直接返回查询缓存中的结果集。



## 并发控制

MySQL有两个层面的并发控制：服务器层与存储引擎层。并发控制还有很长的路要走，我就简单说说~~

### 读写锁

如其名字，就是读锁和写锁。也通常被称为共享锁和排他锁。

简单描述一下：**读锁是共享的，或者相互不阻塞的。**多个客户在同一时刻可以同时读取一个资源，而互不干扰。写锁则是排他的，也就是说一个**写锁会阻塞其他的写锁和读锁，**这是出于安全考虑，这样才能保证给定时间内，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。



### 锁粒度

尽量只锁定需要修改的部分数据，而不是所有资源。**理想就是只是对要修改的数据进行精确锁定。**

如果加锁的范围越大安全性和性能是有提高不用像粒度小的一直检测，但是并发度就会随之下降，所谓锁策略就是在锁的开销性能，安全和并发度之间寻求一个平衡。下面说一下两个不同的锁策略



### 表锁

是最基本的锁策略，是开销最小的策略。在进行写入时会对整张表加锁，这就会阻塞其他用户对该表的所有读写操作。另外写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列前面。



### 行锁

行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。**==行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中锁实现。==**



## 事务

简单来说，事务就是一组原子性的SQL查询，或者一个独立的工作单元。这个工作单元不可在分。要么全部执行，要么回滚。

同时，除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。ACID分别表示：原子性，一致性，隔离性和持久性。一个运行良好的事务处理系统，必须具备这些标准特性。



**原子性（Atomicity）**
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

**一致性（Consistency）**
事务前后数据的完整性必须保持一致。
**隔离性（Isolation）**
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
**持久性（Durability）**
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响



就像锁粒度的升级会增加系统开销一样，这种事务处理过程中额外的安全性，也会需要数据库系统做更多的额外工作。一个实现了ACID的数据库，相比于没有实现ACID的数据库，通常会需要更强的CPU处理能力，更大的内存和更多的磁盘空间。**用户可以根据业务选择存储引擎。**



### 事务隔离级别

**READ UNCOMMITTED(未提交读)：**

​	在这个级别中，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这称为脏读。**这个级别会导致很多问题，但从性能上说，READ UNCOMMITTED不会比其他的级别好太多**，但缺乏其他级别的很多好处，一般很少使用。==**如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过"排他写锁"实现。**==



**READ COMMITTED(提交读):**

​	大多数数据库级别都是这个(但是MySQL不是)。就是说，一个事务开始提交前，所做的任何修改对其他事务都是不可见的。**这个级别叫不可重复读，因为两次执行同样的查询可能会有不同的结果。这可以通过"瞬间共享锁"和"排他写锁"实现。**

​	**脏读:**

 ![image-20201205163534391](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205163536.png)



**REPEATABLE READ(可重复读):**

​	解决了脏读的问题。保证同一个事务中多次读取同样记录的结果是一致的。但是理论上还是无法解决幻读的问题。**禁止了不可重复读和脏读，这可以通过"共享读锁"和"排他写锁"实现。**

​	不可重复读：

![image-20201205163600881](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205163604.png)



**SERIALIZABLE(可序列化):**

​	最高的隔离级别。**简单来说，这个隔离级别会在读取的每一行数据上都上锁，所以可能导致大量的超时和锁争用的问题。**实际应用中很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下才考虑使用。

​	幻读：

 ![image-20201205163640262](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201205163642.png)


### 死锁

死锁是指两个或者多个事务在同意资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环。例如：



事务1：

```sql
start transaction;
updata stockprice set close = 6 where stock_id = 3;
updata stockprice set close = 66 where sotck_id = 4;
commit;
```

事务2：

```sql
start transaction;
updata stockprice set close = 666 where stock_id = 4;
updata stockprice set close = 6666 where stock_id = 3;
commit;
```

如果凑巧这两个事务都执行了第一个语句，都有一个行级锁，接着每个事务都尝试去执行第二条update语句。这两个事务相互占用对方的资源，又都等着对方释放锁。从而导致恶性循环。除非有外部因素介入才可能接触死锁。



为了解决这种问题，数据库系统实现类各种死锁检测和死锁超时机制。**越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。**这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式是，**当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。** 现在InnoDB的处理死锁的方式是，**将持有最少行级排他锁的事务进行回滚(这是相对比较简单的死锁回滚算法)。**



**锁的行为和顺序是和存储引擎相关的。**同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。**死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。**



### 事务日志

事务日志可以帮助提高事务的效率。**使用事务日志，存储引擎在修改表数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都讲修改好的数据本身持久到磁盘。**

事务日志采用的是追加的方式，因此写日志的操作是磁盘上一块区域内对的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，**所以采用事务日志的方式相对来说要快得多。**

事务日志持久后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据需要些两次磁盘

**如果数据的修改已经记录到事务日志并持久化，但数据本省还没有写回磁盘，此时系统崩溃，存储引擎在重启时能自动恢复这部分修改的数据。**具体的恢复方式则视为存储引擎而定。





## 多版本并发控制

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。

**可以认为MVCC是一个行级锁的变种，但是他在很多情况下都避免了加锁操作，因此开销更低。**虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

典型的有乐观锁并发控制和悲观锁并发控制。下面我们看看通过InnoDB的简化版来说说MVCC是如何工作的。



InnoDB的MVCC，是通过每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。==**当然存储的并不是实际的时间，而是系统版本号。每开始一个新的事务，系统版本号回自动递增**==下面看看再REPEATABLE READ隔离级别下，MVCC具体如何操作的。

![image-20201118004259127](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201118004309.png)

**保存这两个版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。**不足是每行记录都需要额外的存储空间，需要做更多的行检测工作，以及一些额外的维护工作。



## MySQL的存储引擎

在文件系统中，MySQL将每个数据库(也可以称之为schema)保存为数据目录下的一个子目录。创建表时，MySQL回在数据库子目录下创建一个和表同名的.frm文件保存表定义。



可是使用show table status 命令现实表相关信息。例如我下面这张表。

![image-20201118005852868](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201118014849.png)

具体数值含义限于篇幅。可自己在网上查阅。



### InnoDB存储引擎

**InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ(可重复读)，并且通过间隙锁策略防止幻读的出现。**间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止行插入。



InnoDB表基于聚簇索引建立的，聚簇索引有很高的性能。**不过它的二级索引(非主键索引)中必须包含主键列**，所以如果主键列很大的话，其他的所有索引就会很大。所以主键应该选择较小的。



**InnoDB内部做了很多优化**，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。同时InnoDB通过一些机制和工具支持真正的热备份。



### MyISAM存储引擎

在MySQL5.1及之前的版本，MyISAM时默认的存储引擎。提供了包括全文索引，压缩，空间函数等，**但是不支持事务和行级锁，而且有一个毫无疑问的缺陷就是奔溃后无法安全恢复。所以尽量使用InnoDB**



MyISAM对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录(并发插入)。



对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。**如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用MyISAM压缩表**。可以使用myisampack对表进行压缩。压缩表是不能进行修改的。压缩表可以极大地减少磁盘空间占比，因此也可以减少磁盘I/O，从而提高查询性能。压缩表也支持索引，但索引也是只读的。



MyISAM引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。MyISAM有一些服务器级别的性能扩展限制，比如对索引键缓冲区的Mutex锁。但MyISAM最典型的性能问题还是表锁问题，如果你发现所有的查询都长期处于"Locked"状态，那毫无疑问表锁就是罪魁祸首。

篇幅有限。剩下的引擎自行了解~~
