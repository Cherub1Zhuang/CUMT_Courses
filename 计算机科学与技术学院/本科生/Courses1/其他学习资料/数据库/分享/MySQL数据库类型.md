# MySQL中数据类型优化

## 选择优化的数据类型

​	MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储那种类型数据，下面几个简单的原则有助于更多的选择



* 更小的通常更好

  更小的数据类型通常更快，因为它们占用更少的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。

* 简单就好

  简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校队规则(排序规则)使字符串比整性更加复杂。例如：应该使用MySQL内建类型(date,time,datatime)而不是字符串来存储日期和时间。

* 尽量避免NULL

  很多表包含NULL的列，即使应用程序不需要保存NULL也是如此，这是因为可为NULL是列的默认属性(如果定义表结构时没有指定列为NOT NULL, 默认都是NULL的)。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值

  **如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个频段的额外字节，在MyISAM里甚至还可能导致固定大小的索引(只有一个整数列的索引)变成可变大小的索引**

  特例当然有，比如InnoDB使用单独的位(bit)存储NULL值，所以对于稀疏数据有很好的空间效率。但这不适用于MyISAM

## 整数类型

​	有两种类型的数字：整数和实数。如果存整数，可以使用这几种整数类型:TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别使用8，16，24，32， 64位存储空间。**他们都是有符号数。范围可以的出来了吧。**另外还有可选得属性UNSIGNED，即不允许有负值，可以让存的正数多一位。

​	同时MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具(例如MySQL命令行客户端)用来显示字符的个数。**对于存储和计算来说，INT(1)和INT(20)是相同的。**



## 实数类型

​	实数是带有小数部分的数字。**然而，它们不只是为了存储小数部分，也可以使用DECIAML存储比BIGINT还大的整数。**MySQL既支持精确类型，也支持不精确类型。FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。如果需要知道浮点运算是怎么计算的，则需要研究所使用的平台的浮点数的具体实现。

​	DECIMAL类型用于存储精确的小数。在MySQL5.0和更高版本，DECIAML类型支持精确计算。MySQL4.1以及更早版本则使用浮点运算来实现DECIAML的计算，这样做会因为精度损失导致一些奇怪的结果。**在这些版本中，DECIMAL只是一个"存储类型"。**

​	因为CPU不支持对DECIMAL的直接计算，所以在MySQL5.0以及更高版本中，**MySQL服务器自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快。**

​	浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。例如：**DECIMAL(18,9)总共能存18位数字，末尾是9位小数，字段最大值是：999999999.99999999**

​	在MySQL5.0和更高版本中的DECIMAL类型允许最多65个数字。而早期的MySQL版本中这个限制是254个数字，并且保存为未压缩的字符串(每个数字一个字节)。**然而实际中并不会用这么大的数字，因为DECIMAL只是一种存储格式；在计算中DECIMAL会转换为DOUBLE类型。**

​	因为需要额外的空间和计算开销。所以应该尽量只在对小数进行精确计算时才使用DECIMAL - 例如存储财务数据。也可以使用BIGINT代替DECIMAL，然后再进行乘除就可以。



## 字符串类型

### VARCHAR和CHAR类型

​	VARCHAR和CHAR是两种最主要的字符串类型。不幸的是，很难精确地解释这些值是怎么存储在磁盘和内存中的，因为这个和存储引擎的具体实现有关。这主要讲的是InnoDB和MyISAM存储引擎。



### VARCHAR

​	VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，以你为它仅使用必要的空间。有一种情况例外，**如果MySQL表使用ROW_FORMAT = FIXED创建的话，每一行会使用定长存储。**

​	**VARCHAR需要使用1或2个额外字节记录字符串的长度**，如果列的最大长度小于或等于255字节，则只使用1个字节表示 ，否者使用2个字节。**例如VARCHAR(10)的列需要11个存储空间。VARCHAR(1000)则需要1002个字节**

​	VARCHAR节省了存储空间，所以对性能有帮助。**但是由于行是变长的，在UPDATE时可能使行变得比原来长，这就导致额外的工作。**如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，这种情况下，不同存储引擎的处理方式是不一样的。例如MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。所以这将会耗费时间。



​	总结：这些情况下使用VARCHAR是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都是用不同的字节数进行存储。



### CHAR

​	CHAR类型是定长的。MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。**CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如CHAR很适合存MD5值，这是个定长的值。**对于经常变更的数据，CHAR也比VARCHAR更好，定长不会产生碎片。



​	与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，他们存储的是二进制字符串。

![image-20201122215056956](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201122223512.png)





## BLOB和TEXT类型

​	BLOB和TEXT都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。

​	实际上他们分别属于不同的数据类型家族：字符串类型是TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT; 对应的二进制类型是TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB。



​	和其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。**当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1 ~ 4个字节存储一个指针，然后在外部存储区域存储实际的值。**

​	**==MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。==**



## 日期和时间类型

​	MySQL可以有很多类型保存日期时间。最小的时间粒度是秒。大部分时间类型都是没有替代品的，因此没有什么是最佳选择的问题。唯一的问题是保存日期和时间的时候需要做什么。MySQL提供两种相似的日期类型：**DATETIME和TIMESTAMP。对于很多应用程序，他们都能工作，但是在某些场景，一个比另一个工作得更好。**



### DATETIME

​	这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储默认空间。

​	默认情况下，MySQL以一种可排序的，无歧义的格式显示DATETIME值，例如"2020-11-22 22:07:59"。这是ANSI标准定义的日期和时间表示方法。



### TIMESTAMP

​	类型保存了从1970年1月1日午夜以来的秒数，和UNIX时间戳相同。**TIMESTAMP只使用4个字节的存储空间，因此范围比DATETIME小得多：只能表示从1970到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期。**

​	相对麻烦的是，TIMESTAMP显示的值也依赖于时区。MySQL服务器，操作系统，以及客户端连接都有时区设置。



## 特殊的数据类型

​	某些类型的数据并不直接与内置类型一致。低于秒精度的时间戳就是一个例子；

​	另一个例子是一个IPv4地址。经常会使用VARCHAR(15)列来关联IP地址。然而，他们实际上是32位无符号整数，不是字符串。用小数点将地址分成四段的表示方法只是为了让人们容易阅读。所以应该用无符号整数存储IP地址。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。