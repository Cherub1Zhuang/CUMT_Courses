​		增加缓存对IO的性能会有很大的提升，但增加一层缓存后，不得不面对的就是老大难问题就是如何保证数据的一致性，缓存层数越多，复杂程度也至少成倍。相对于性能来说，数据的一致性明显优先级更高。因此如何在提升性能的情况下再保证数据的一致性，这就很考验代码对缓存数据的管理了。而保证数据的有效性中，最普遍的就是操作数据时对数据加锁，而本次性能优化中对缓存数据的管理加锁方式采用的是读写锁。

​    读写锁是非常常用的一种锁，一个共享数据，为了保证数据一致性，所有操作者去操作数据前都要先加锁，保证本操作者使用该数据时数据不被其他操作者修改，而对数据的操作只有两种，读取和写入，因为读取不会修改数据，因此读取操作可以同时允许多个操作者，而写入操作在一个时间段只允许一个操作者，也就是读锁可以加多次，而写锁只能加一次。以下表格就列举出数据在当前锁状态下对应的加锁结果。

|          | 读取               | 写入               |
| -------- | ------------------ | ------------------ |
| 无锁     | 加读锁成功，读锁+1 | 加写锁成功，写锁+1 |
| 已加读锁 | 加读锁成功，读锁+1 | 加写锁失败         |
| 已加写锁 | 加读锁失败         | 加写锁失败         |

​		从读写锁性质来看，写锁的优先级要比读锁高，但实际过程中如果因为调度等关系，导致数据一直被流程加上读锁，而写锁加不到，从而导致加写锁饿死，这是一个很严重也比较常见的问题，为了解决这种问题，可以增加一种写锁状态，称之为trywrite锁，先占个写锁坑，但实际还没完全加上写锁，如果加了trywrite锁后，就无法加上读锁，等当前已加的所有读锁释放完，再次调度到加写锁的线程时就能成功加上写锁了。当然类似的也有一直加写锁，而读锁加不到的场景，同样也可以以类似方式来处理。

​		有加锁操作，那同样对应的就有解锁操作，从设计逻辑上需要完全保证加解锁配对，不管是正常流程还是异常处理，否则必然会有严重问题，最常见的就是死锁。因此在实际场景中，如果一个操作需要获取多个锁时，建议一次性获取所有需要的锁，如果获取不到，直接将已加的锁全部释放。如果增加多种机制获取锁，比如冲突场景下通过锁释放操作来回调其他希望获取锁操作，在很多场景下稍不注意还是容易造成死锁，有时候最简单的往往才是最合理的。

​		读写锁的实现很简单，两个引用计数就足够了，一个读引用计数，一个写引用计数，如何定义和使用，还是需要根据实际应用场景来定，只要理解了读写锁的思想，就会发现真的很简单。
