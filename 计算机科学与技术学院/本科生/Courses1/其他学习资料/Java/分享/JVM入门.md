# JVM内存结构

## 运行时数据区

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

![image-20201111004451671](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201111004500.png)



这之中可以通过线程共享和不共享来区分

## 线程私有

### 程序计数器

是一块较小的内存空间，可以当作当前线程锁执行的字节码的行号指示器。当前线程的执行是通过执行字节码来的。所以这个程序计数器就是通过改变程序计数器来执行指令。**他是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基本操作都是依赖这个计数器完成**



### Java虚拟机栈

每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法被调用直到执行完毕的过程就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。

而"栈"通常讲的是虚拟机栈，或者更多情况是指虚拟机栈中的局部变量表部分。

局部变量表存放了编译器可知的各种Java虚拟机基本数据类型(boolean, byte, char, short, int, float, long, double)，对象引用(reference类型，不等同于一个对象，是指向对象所在的地址)和returnAddress类型(指向了一条字节码指令的地址 例如中断)

其实同字节码中表示的code属性中是相差不大的，都是变量槽。64位的需要两个变量槽来存。然后局部变量槽可以进行重用。



对这个区域有两种异常情况:

线程请求的栈大小大于虚拟机所允许的栈大小会有StackOverflowError异常。

如果Java虚拟机栈容量可以动态扩展，动态扩展后都无法满足线程的需求就会有OutOfMemoryError

**但是HotSpot的栈容量是无法扩展的。所以栈是无法导致OOM问题的。**




### 本地方法栈

本地方法栈和虚拟机栈差不多相同，只是虚拟机栈是为了Java的方法服务。而本地方法栈是为**虚拟机使用到本地方法服务。** 

本地方法栈中，方法使用的语言，使用方式和数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现。

同样。同Java虚拟机栈，栈深度溢出或者扩展失败后会有stackoverflow和oom的情况



## 线程共享

### Java堆

是虚拟机管理的最大的一块内存。这个内存唯一的目的就是存放对象实例。几乎所有对象实例和数组都在堆上分配。

Java堆是垃圾收集器的管理区域。堆中经常会有什么"新生代" "老年代" "永久代"等等。

从分配内存来看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区TLAB。以提高对象分配时的效率。

从中可以看到，堆这个区域被不断地划分。但是，堆的本质还是存的是对象实例，讲堆分区时为了更好的回收内存或是分配内存但是本质永远不会改变



顺便说说TLAB：TLAB是虚拟机在堆内存的eden划分出来的一块专用空间线程专属。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如需要分配内存，在自己的空间上分配，在不存在竞争的情况大大提升分配效率。



### 方法区

存一些已被虚拟机记载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。时Java堆中的一个逻辑部分。但是他的别名是"非堆"目的是为了区分"堆"



jdk1.8以前，实现这个区域的是永久代。当时选择讲收集器的分代设计扩展至方法区。这使得垃圾收集器像管理堆一样管理这个区域。省去专门编写管理方法区内存管理的方法。这种方法导致的一个问题就是这个区域很容易遭遇内存溢出的问题(永久代有上限，可以通过-XX:MaxPermSize的上限，只要不触碰到进程使用内存的上限就没有问题)



但是极少数方法，比如String::intern()会因为永久代的原因导致不同虚拟机下有不同表现



到了jdk1.8就是直接用本地内存实现方法区了。转而实现方法就是元空间。

(Java虚拟机规范)对这个区域很宽松，同堆一样可以不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集在这个区域很少。

这个区域的内存回收目标主要是针对常量池的回收和类型的卸载。一般来说效果是较差的。特别是类型的卸载，条件相当苛刻，但是这部分回收是很必要的。

如果内存无法满足会抛出oom的异常



#### 运行时常量池

是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

虽然Java对class的字节码很严格，但是对于这个区域，没有任何细节要求。不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。

同时在内存不够的时候会抛出oom的异常。