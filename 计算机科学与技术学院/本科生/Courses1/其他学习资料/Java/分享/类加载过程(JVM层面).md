# 类加载过程

目录:

* [概述](#概述)
* [加载](#加载)
* [准备](#准备)
* [验证](#验证)
* [解析](#解析)
* [初始化](#初始化)
* [类加载时机](#类加载时机)



## 概述

一个类型从被加载到虚拟机内存中开始，到卸载为止，它的整个生命周期将会经历加载，验证，准备，解析，初始化，使用，卸载七个阶段。其中验证，准备，解析三个部分统称为连接。

![image-20201115011959652](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201116020001.png)

加载，验证，准备，初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序按部就班的开始(这些阶段通常都是相互交叉地混合进行，会在一个阶段执行的过程中调用)

而解析阶段则不一定：在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性(也称为动态绑定或晚期绑定)。

接下来讨论加载，验证，准备，解析和初始化这五个阶段所执行的具体操作。



## 加载

在加载阶段，Java虚拟机需要完成以下三件事

* 从一个类的全限定名来获取定义此类的二进制字节流。(全限定名即包名.类名, 并没有说要从一个Class文件中获取，可以从其他渠道，例如:动态生成，ZIP, JAR, WAR等)
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

相对于其他阶段，非数组类型的加载阶段是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载去完成(重写一个类加载器findClass()或loadClass()方法)。

对于数组类，本身不通过类加载器创建，它是**由Java虚拟机直接在内存中动态构造出来**的。但是数组中的元素终归还是要用类加载器完成

特别的，**加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的**，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间任然保持着固定的先后顺序。



## 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

class文件不一定是Java源码编译出来的。也可以自己手动敲出来。不能完全信任字节码

Java是相对安全的语言(起码对于C/C++来说是安全的)，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据，将一个对象转型为他并未实现的类型，跳转到不存在的代码行之类的事

但保证安全的同时，不可避免的要占执行时间。

 验证阶段大致会完成4个阶段的检验动作：

* 文件格式验证：验证字节流是否符合Class文件格式的规范(例如，魔数，次版本号，主版本号，常量池等等)
* 元数据验证：对字节码描述的信息进行语义分析，以保证描述的信息符合Java语言规范的要求(例如，是否有java.lang.Objec，是否继承了不允许被继承的类，被final修饰的类，抽象类要满足的条件等等)
* 字节码验证：最复杂的阶段，通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。例如：保证跳转指令不会跳转到方法体以外的字节码指令上。其中为了减少时间消耗在验证字节码阶段，在JDK6之后的Javac编译器和Java虚拟机进行一系列联合优化，尽可能多的把校验辅助措施挪到了Javac编译器进行。具体在Code属性表中增加了名为"StackMap Table"的新属性。在字节码验证期间就直接检测StackMapTable中属性值是否合法即可。但问题也可以通过修改class文件修改stackmaptable的值，所以这是一个问题
* 符号引用验证：确保解析动作能正确执行。这个阶段发生在虚拟机讲符号引用转化为直接引用的时候，即第三阶段解析中发生。主要检查该类是否确实或者被禁止访问他依赖的某些外部类，方法，字段等资源。例如：符号引用中通过全限定名是否能找到对应的类，是否存在简单名称所描述的方法和字段。



## 准备

**准备阶段是正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值(零值)的阶段，这些变量所使用的内存都将在方法去中进行分配。**这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会再对象实例化分配在堆中。这里说的初始值通常情况下是数据类型的零值。

![image-20201115215448768](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20201116015952.png)



这里说的都是通常情况是零值，那特殊情况呢？如果类字段的字段属性表中存在ConstantValue属性，那再准备阶段变量值就会被初始化为Constant Value属性所指定的初始值。



## 解析

解析阶段是虚拟机讲常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行。



**符号引用**：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，子要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。

**直接引用**：直接引用时可以直接指向目标的指针，相对偏移量或者是一个能简介定位到目标的句柄。直接引用和虚拟机的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不相同。那引用的目标必定已经在虚拟机的内存中存在了。



## 初始化

类初始化阶段是类加载过程最后一步。在前面的类加载过程中，出来再加载阶段用户应用程序可以通过自定义类加载参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(字节码)



简单来说，初始化阶段是执行类构造器clinit()方法的过程。clinti()方法是由编译器自动手机类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器手机的顺序是由语句再源文件中出现的顺序所决定的，**静态语句块只能访问到定义再静态语句块之前的变量，定义在他之后的变量，再前面的静态代码块可以赋值，但是不能访问。**

例如：

```java
class test {
    static {
        i = 22; // 可以正常通过
        System.out.println(i); // 这句编译器会提示'非法向前引用'
    }
    static int i;
}
```

clinit方法与类的构造函数(即在虚拟机视角中的实例构造器init()方法)不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的clinit方法执行前，父类的clinit方法已经执行完毕。因此Java虚拟机中第一个被执行的clinit方法的类型肯定是java.lang.Object。



同时clinit方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit方法。



**Java虚拟机必须保证一个类的clinit方法在多线程环境中被正确地加锁同步**，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的clinit方法，其他线程要等待，直到线程执行完clinit方法。如果clinit方法中有耗时的操作可能会造成多个进程阻塞。而且这种阻塞很隐蔽 。

例如：

```java
package zou;

class test {
    static {
        if (true) {
            System.out.println(Thread.currentThread().getName() + "init");
            while (true) {

            }
        }
    }
}

public class 多线程的clinit方法 {
    public static void main(String[] args) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "start");
            test test = new test();
            System.out.println(Thread.currentThread().getName() + "over");
        }, "A").start();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "start");
            test test = new test();
            System.out.println(Thread.currentThread().getName() + "over");
        }, "B").start();
    }
}
```

输出的结果, A线程会一直卡在while语句中导致B线程在阻塞等待。

```python
Astart
Bstart
Ainit
```



## 类加载时机

### 类加载时机

什么情况下虚拟机开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

### 类初始化时机

虚拟机规范中有严格规定，虚拟机规范指明**有且只有**六种情况必须立即对类进行初始化



1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令（注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：

- 使用new关键字实例化对象的时候；
- 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
- 调用一个类的静态方法的时候。

------

　　2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

　　3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

　　4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

　　5) 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

​		6) 一个接口定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果这个接口的实现类发生了初始化。那这个接口一定要在之前初始化。



这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会出发初始化，称为被动引用。



### 3种被动引用经典例子

**1.通过子类引用父类静态字段，子类不会初始化**

类名取得有点抽象==

```java
package classinittest;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

class base {
    static {
        System.out.println("base init");
    }
}
class pre extends base {
    static {
        System.out.println("pre init");
    }
    static int a = 1;
}
class now extends pre {
    static {
        System.out.println("now init");
    }
}
public class test {
    public static void main(String[] args) {
        System.out.println(now.a);
    }
}
/** output
base init
pre init
1
*/
```

可见不会输出now init，子类不会被初始化。是否会触发子类初始化。在Java虚拟机规范中没有明确给出。对于HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作是会导致子类加载的。



**2.通过数组定义来引用类，不会触发此类的初始化**

和前面的类复用一下。

```java
public class test {
    public static void main(String[] args) {
        // System.out.println(now.a);
        now[] now = new now[10];
    }
}
```

这个就什么都不会输出。

这里并没有对全限定名进行初始化。这段代码出发了另一个名为"[[全限定名]"的类的初始化，他是一个由虚拟机自动生成的，直接继承于`java.lang.Object`的子类，创建动作由字节码指令`newarray`触发。



**3.引用类的常量不会触发该类的初始化**

```java
package classinittest;

class hh {
    static {
        System.out.println("hh init");
    }
    static final int a = 1;
}
public class constvalue {
    public static void main(String[] args) {
        System.out.println(hh.a);
    }
}
/*output
1
*/
```

单单输出一个1，没有输出hh init说明hh类并没有进行初始化。

从我学习的class文件格式的知识中就了解可能在属性表中有个ConstValue属性。在准备阶段就已经把值赋进去了。所以我理解的就是现在的a变量已经不在hh类中了。

深入理解Java虚拟机第三版是这样解释的：

上述代码运行之后，只输出 “1”，这是因为虽然在Java源码中引用了hh类中的常量CONSTANT，但是编译阶段将此常量的值“1”存储到了NotInitialization常量池中，对常量hh.CONSTANT的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有hh类的符号引用入口，这两个类在编译为Class文件之后就不存在关系了。
