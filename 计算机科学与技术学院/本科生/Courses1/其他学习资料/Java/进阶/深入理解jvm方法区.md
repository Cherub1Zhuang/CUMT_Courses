# 方法区

## 简介

方法去在JVM中是一个非常重要的区域，就像堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息(包括类的名称，方法信息，字段信息)，静态变量，常量以及编译器编译后的代码等。

**方法区: ** 只是JVM规范中定义的一个概念，用于存储类信息，常量池，静态变量，JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而**永久代**时Hotspot虚拟机特有的概念，时方法区的一种实现，别的JVM没有这个东西。

## 方法区结构

先看看`classLoader`时如何加载class文件和存储文件信息的：

当一个`classLoader`启动的时候，classLoader的生成地方是jvm堆中，然后它会去主机硬盘上将A.class装载到jvm的方法区，**方法区中的这个字节文件会被虚拟机拿来`new A字节码()`，然后在堆内存生成一个A字节码的对象，然后A字节码这个内存文件有两个引用，一个指向A的class文件，一个指向加载自己的classLoader。**那么方法区中的字节码内存块，除了记录一个指向自己的class文件的引用和加载自己的ClassLoader引用。还有如下：

![285763-20170804120525287-900194223](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20210224213241.png)



## 方法区关键信息介绍

### 类信息：

修饰符(public final):

​	是类还是接口(class,interface)

​	类的全限定名(Test/ClassStruct.class)

​	直接父类的全限定名(java/lang/Object.class)

​	直接父接口的权限定名数组(java/io/Serializable)

​	也就是 public final class ClassStruct extends Object implements Serializable这段描述的信息提取

### 字段信息

修饰符(private):

​	字段类型(java/lang/String.class)

​	字段名(name)

### 方法信息

修饰符(public staitc final):

​	方法返回值(java/lang/String.class)

​	方法名(getStatic_str)

​	参数需要用到的局部变量的大小还有操作数栈大小(操作数栈我们后面会讲)

​	方法体的字节码(就是花括号里的内容)

​	异常表(throws Exception)

​	也就是对方法public static final String getStatic_str ()throws Exception的字节码的提取

### 静态常量池

直接常量：

​	CONSTANT_INGETER_INFO整型直接常量池public final int CONST_INT=0;

​	CONSTANT_String_info字符串直接常量池  public final String CONST_STR="CONST_STR";

​	CONSTANT_DOUBLE_INFO浮点型直接常量池

​	等等各种基本数据类型基础常量池(待会我们会反编译一个类，来查看它的常量池等。)

方法名，方法描述符，类名，字段名，字段描述符的符号引用

也就是所有编译器能够确定，能偶被快速查找的内容放在这里，它像数组一样通过索引访问，专门用来作为查找使用。

编译时就能确定数值的常量类型都会复制它的所有常量到自己的常量池中，或者嵌入到它的字节码流中，作为常量池或者字节码流的一部分，**编译时常量保存在方法区中**，就和一般的类变量一样。但是当一般的类变量作为他们的类型的一部分数据而保存的时候，编译常量作为使用它们的类型的一部分而保存。

### 类变量(静态变量):

​	就是静态字段(public static String static = "static_str";)

​	虚拟机在使用某个类之前，必须在方法区为这些变量分配空间

### 一个到classLoader的引用

通过this.getClass.getClassLoader来获取classLoader，其间要经过Class来获取。

### 一个到class对象的引用

这个对象存储了所有这个字节码内存块的相关信息。所有你能够看到的区域，比如：类信息，你可以通过this.getClass().getName()取得

所有的方法信息，可以通过this.getClass().getDeclaredMethods()，字段信息可以通过this.getClass().getDeclaredFields()，等等，所有在字节码中你想得到的，调用的，通过class这个引用基本都能够帮你完成。**因为他就是字节码在内存块在堆中的一个对象**

### 方法表

如果学习c++的人应该都知道c++的对象内存模型有一个叫虚表的东西，java本来的名字就叫c++- -，它的方法表其实说白了就是c++的虚表，它的内容就是这个类的所有实例可能被调用的所有实例方法的直接引用。也是为了动态绑定的快速定位而做的一个类似缓存的查找表，它以数组的形式存在于内存中。不过这个表不是必须存在的，取决于虚拟机的设计者，以及运行虚拟机的机器是否有足够的内存。





# 常量池

方法区说完了，我们来详细说说这个常量池：

请注意常量池时线程共享数据区，常量池的内容：

![6f35483032cffbfbd35c79bca03794ac](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20210224213235.png)

常量池的好处:

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。

​	(1) 节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间

​	(2) 节省运行时间：比较字符串时，比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。



## 静态常量池

静态常量池也就是Class文件中的常量池，下面用一张图来看看静态常量池在Class文件中的位置：

![cb1ec3d8c70411fe51e7dd6d55c4b367](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20210224213251.png)

从上图可以看出，Class文件中包含有静态常量池：

静态常量池**用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。**其中符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。

当Class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到运行时常量池里，在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。



## 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

运行时常量池还有个更重要的的特征：动态性。Java要求，编译期的常量池的内容可以进入运行时常量池，运行时产生的常量也可以放入池中。常用的是String类的intern()方法。

既然运行时常量池是方法区的一部分自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## 字符串常量池

字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。

字符串常量池的存在使JVM提高了性能和减少了内存开销。

使用字符串常量池，每当我们使用字面量（String s="1";）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就将此字符串对象的地址赋值给引用s（引用s在Java栈中）。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此字符串对象的地址赋值给引用s（引用s在Java栈中）

 

**使用字符串常量池，每当我们使用关键字new（String s=new String("1");）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s**

下图是API说明：

![image-20210224020825911](https://zouyishan.oss-cn-beijing.aliyuncs.com/images/20210224213256.png)

翻译为：“初始化一个新创建的字符串对象，以便它表示与参数相同的字符序列；换句话说，新创建的字符串是参数字符串的副本。除非需要显式的原始副本，否则使用此构造函数是不必要的，因为字符串是不可变的。”

**由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串**

**鉴于String.intern()在API上的说明和new String("a")创建字符串（创建了两个对象，如果字符串常量池存在则是一个对象）在官方API上的说明，我个人认为字符串常量池存的是字符串对象，当然在JKD7之后，常量池中存储的可能是堆对象的引用**



`在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是key-value键值对，上面也说了，常量池是线程共享数据区，这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享（享元模式）`

字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  



### 说说String和StringBuilder和StringBuffer的区别

String不可变，因为String底层实现是通过final的char，所以没法改变。而StringBuilder和StringBuffer是通过继承一个AbstractStringBuffer。其中的底层实现是一个char数组。其中的道理是因为字符串常量池的原因。如果String能改变那么引用就会乱套，比如改变一个对象就会印象到另一个独立的对象。



StringBuffer是线程安全的，StringBuilder是非线程安全的。StringBuffer就是粗暴加锁。但是相较于字符串拼接，String类型会创建一个新的对象，然后新的对象又指向引用，就会很浪费时间。但StringBuilder是jdk5出来相对于StringBuffer的替代，单线程建议使用。

